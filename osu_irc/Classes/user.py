from typing import TYPE_CHECKING, Set, List
if TYPE_CHECKING:
	from .client import Client
	from .channel import Channel

import re
from .undefined import UNDEFINED
from ..Utils.regex import ReUserName, ReRoomName

class User(object):
	"""
	This class represents a osu user,
	the same user object meight be found in multiple Channel.chatters dict's.

	NOTE: all users from all channels can be found ion Client.users
	NOTE 2: also there are no ID's because why should it, REEEEEEE (i really like ID's... :c)
	"""
	def __repr__(self):
		return f"<{self.__class__.__name__} name='{self.name}'>"

	def __str__(self):
		return self.name or ""

	def __init__(self, raw:str or None):
		self._name:str = UNDEFINED
		self._generated_via_channel:str = UNDEFINED

		self.found_in:Set[str] = set()

		if raw != None:
			try:
				self.userBuild(raw)

			except:
				raise AttributeError(raw)

	def compact(self) -> dict:
		d:dict = {}
		d["name"] = self.name
		d["found_in"] = self.found_in
		return d

	# utils
	def userBuild(self, raw:str) -> None:
		"""
		generated by a LEFT or JOIN Event like:

		```
		:The_CJ!cho@ppy.sh JOIN :#osu
		```
		"""

		# _name
		search = re.search(ReUserName, raw)
		if search != None:
			self._name = search.group(1)

		# _generated_via_channel
		search = re.search(ReRoomName, raw)
		if search != None:
			self._generated_via_channel = search.group(1)

	# func
	def foundInChannels(self, cls:"Client") -> List["Channel"]:
		"""
		Returns a list of channels this user is currently in,
		requires you to give this function the Client class, don't ask why...
		Like this:
		```
		async def onUserJoin(self, NewChan, SomeUser):
			channels_a_user_is_in = SomeUser.foundInChannels(self)
			print(f"{SomeUser.name} is now in {len(channels_a_user_is_in)} different channels")
		```
		"""

		ret:List["Channel"] = []

		for channel_name in self.found_in:

			Ch:"Channel" = cls.channels.get(channel_name, None)
			if Ch: ret.append(Ch)

		return ret

	# props
	@property
	def name(self) -> str:
		return str(self._name or "")
